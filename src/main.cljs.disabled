(ns cljs-async
  (:require [clojure.browser.repl :as repl]
            [cljs.core.async :refer [chan timeout <! >! put!]])
  (:require-macros [cljs.core.async.macros :refer [go alt!]]))

(repl/connect "http://localhost:9000/repl")

(defn el
  ([tag] (el tag {} ()))

  ([tag arg]
   (cond
     (map? arg) (el tag arg ())
     :else (el tag {} arg)))

  ([tag attributes children]
   (let [element (js/document.createElement tag)]

     ; Assign attributes
     (doseq [[attr value] attributes]
       (aset element (name attr) value))

     ; Append children.
     (doseq [child children]
       (.appendChild element child))

     element)))

(defn make-grid [cols rows]
  (let [make-cell (fn [x y] (el "b" {:id (str "b-" x "-" y)}))
        make-row (fn [y] (el "div" {:className "row"} (map #(make-cell % y) (range cols))))
        grid (el "div" {:id "grid"} (map make-row (range rows)))]
    grid))

#_
(let [grid (make-grid 20 20)]
  (js/document.body.appendChild grid)
  (.addEventListener grid "mousemove" (fn [event]
                                        (let [element (.-target event)]
                                          (when (= (.-tagName element) "B")
                                            (aset element "className" "on"))))))

#_
(let [c (chan)]
  (go (while true
        (<! (timeout 500))
        (>! c "hi")))
  (go (while true
        (<! (timeout 1000))
        (>! c "bye")))
  (go (while true
        (<! (timeout 2000))
        (>! c "what?")))
  (go (while true
        (console/log (<! c))))
  (go (while true
        (console/log (str "                        " (<! c))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def request-frame
  (or (.-requestAnimationFrame js/window)
      (.-webkitRequestAnimationFrame js/window)
      (.-mozRequestAnimationFrame js/window)
      (.-oRequestAnimationFrame js/window)
      (.-msRequestAnimationFrame js/window)
      (fn [callback] (js/setTimeout callback (/ 1000 60)))))
(def cancel-frame
  (or (.-cancelAnimationFrame js/window)
      (.-webkitCancelAnimationFrame js/window)
      (.-mozCancelAnimationFrame js/window)
      (.-oCancelAnimationFrame js/window)
      (.-msCancelAnimationFrame js/window)
      (fn [frame-id] (js/clearTimeout frame-id))))

(defn current-time
  "Returns the Unix epoch time in seconds."
  [] {:post [(pos? %)]}
  (/ (new js/Date) 1000.0))

(defn request-frame-chan []
  (let [c (chan)]
    (letfn [(f [previous-time]
              (let [time (current-time)
                    dt (- time previous-time)]
                (put! c dt)
                (request-frame (partial f time))))]
      (request-frame (partial f (current-time))))
    c))

(defn event-chan [el type]
  (let [c (chan)]
    (.addEventListener el type #(put! c %))
    c))

(let [[width height] [640 480]
      radius 20
      canvas (el "canvas" {:id "canvas"})
      brush (.getContext canvas "2d")
      mousemove (event-chan js/window "mousemove")
      frame (request-frame-chan)]
  (js/document.body.appendChild canvas)
  (set! (.-width canvas) width)
  (set! (.-height canvas) height)
  (set! (.-fillStyle brush) "red")

  (go
    (loop [state {:pos [0 0]}]
      (recur
        (alt!
          mousemove ([event]
                     (let [x (- (.-pageX event) (.-offsetLeft canvas))
                           y (- (.-pageY event) (.-offsetTop canvas))]
                       (assoc state :pos [x y])))
          frame ([dt]
                 ;; Draw a circle at the current position.
                 (let [[x y] (:pos state)]
                   (doto brush
                     (.clearRect 0 0 width height)
                     (.beginPath)
                     (.arc x y radius 0 (* 2 js/Math.PI) false)
                     (.closePath)
                     (.fill)))
                 state))))))

(let [a (chan) b (chan)]
  (go (while true
        (console/log (<! a))
        (console/log (<! b))))
  (dotimes [i 10]
    (put! b i))
  (put! a "start"))

